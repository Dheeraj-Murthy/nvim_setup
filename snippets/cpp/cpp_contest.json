{
  "summer": {
    "prefix": "summer",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
    "#define rep(i,k,n) 	for(ll i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)",
      "#define debarr(arr) for(ll xxx = 0; xxx < arr.size(); xxx++) cout <<  arr[xxx] << ' '; cout<< endl;",
    "#define deb(x) 		cout << #x << \"=\" << x << endl",
      "#define deb2(x, y)  cout << #x << \" and \"  #y << \": (\" << x << \", \" << y << \")\\n\";",
    "#define ll	long long",
    "#define pb	push_back",
    "#define mp	make_pair",
    "#define F	first",
    "#define S	second",
    "#define all(x)		x.begin(), x.end()",
    "#define clr(x)		memset(x, 0, sizeof(x))",
      "#define sz(x) (int) (x).size()",
    "#define sortall(x)	sort(all(x))",
    "#define tr(it, a)	for(auto it = a.begin(); it != a.end(); it++)",
    "#define PI	3.1415926535897932384626",
    "typedef pair<int, int>	pii;",
    "typedef pair<ll, ll>	pl;",
    "typedef vector<int>		vi;",
    "typedef vector<ll>		vl;",
    "typedef vector<pii>		vpii;",
    "typedef vector<pl>		vpl;",
    "typedef vector<vi>		vvi;",
    "typedef vector<vl>		vvl;",
      "mt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());",
      "int rng(int lim) {",
      "  uniform_int_distribution<int> uid(0,lim-1);",
      "  return uid(rang);",
      "}",
      "",
      "const int mod = 1000000007;",
      "const int N = 1e6 + 7, M = N;",
      "//=======================",
      "",
      "",
      "void solve() {",
      "  ${0}",
      "}",
      "",
      "",
      "int main() {",
      "  ios::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int t = 1;",
      "  cin >> t;",
      "  while(t--) {",
      "      solve();",
      "  }",
      "",
      "  return 0;",
      "}",
      ""
    ],
    "description": "basic"
  },
  "modulo": {
    "prefix": "mint",
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a;",
      "    swap(a, m);",
      "    u -= t * v;",
      "    swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "",
      "template <typename T>",
      "class Modular {",
      "public:",
      "  using Type = typename decay<decltype(T::value)>::type;",
      "",
      "  constexpr Modular() : value() {}",
      "  template <typename U>",
      "  Modular(const U &x) {",
      "    if constexpr (std::is_floating_point<U>::value) {",
      "      value = normalize(static_cast<Type>(std::round(x)));",
      "    }",
      "    else {",
      "      value = normalize(x);",
      "    }",
      "  }",
      "",
      "  template <typename U>",
      "  static Type normalize(const U &x) {",
      "    Type v;",
      "    if (-mod() <= x && x < mod())",
      "      v = static_cast<Type>(x);",
      "    else",
      "      v = static_cast<Type>(x % mod());",
      "    if (v < 0)",
      "      v += mod();",
      "    return v;",
      "  }",
      "",
      "  const Type &operator()() const { return value; }",
      "  template <typename U>",
      "  explicit operator U() const { return static_cast<U>(value); }",
      "  constexpr static Type mod() { return T::value; }",
      "",
      "  Modular &operator+=(const Modular &other) {",
      "    value += other.value;",
      "    value -= (value >= mod()) * mod();",
      "    return *this;",
      "  }",
      "  Modular &operator-=(const Modular &other) {",
      "    value -= other.value;",
      "    value += (value < 0) * mod();",
      "    return *this;",
      "  }",
      "  template <typename U>",
      "  Modular &operator+=(const U &other) { return *this += Modular(other); }",
      "  template <typename U>",
      "  Modular &operator-=(const U &other) { return *this -= Modular(other); }",
      "  Modular &operator++() { return *this += 1; }",
      "  Modular &operator--() { return *this -= 1; }",
      "  Modular operator++(int) {",
      "    Modular result(*this);",
      "    *this += 1;",
      "    return result;",
      "  }",
      "  Modular operator--(int) {",
      "    Modular result(*this);",
      "    *this -= 1;",
      "    return result;",
      "  }",
      "  Modular operator-() const { return Modular(-value); }",
      "",
      "  template <typename U = T>",
      "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {",
      "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {",
      "    int64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
      "    value = normalize(value * rhs.value - q * mod());",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {",
      "    value = normalize(value * rhs.value);",
      "    return *this;",
      "  }",
      "",
      "  Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
      "",
      "  friend const Type &abs(const Modular &x) { return x.value; }",
      "",
      "  template <typename U>",
      "  friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
      "",
      "  template <typename U>",
      "  friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
      "",
      "  template <typename V, typename U>",
      "  friend V &operator>>(V &stream, Modular<U> &number);",
      "",
      "private:",
      "  Type value;",
      "};",
      "",
      "template <typename T>",
      "bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U>",
      "bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
      "template <typename T, typename U>",
      "bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
      "",
      "template <typename T>",
      "bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U>",
      "bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U>",
      "bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T>",
      "bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
      "",
      "template <typename T>",
      "Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
      "",
      "template <typename T>",
      "Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T>",
      "Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T>",
      "Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U>",
      "Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
      "",
      "template <typename T, typename U>",
      "Modular<T> power(const Modular<T> &a, const U &b) {",
      "  assert(b >= 0);",
      "  Modular<T> x = a, res = 1;",
      "  U p = b;",
      "  while (p > 0) {",
      "    if (p & 1)",
      "      res *= x;",
      "    x *= x;",
      "    p >>= 1;",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename T>",
      "bool IsZero(const Modular<T> &number) {",
      "  return number() == 0;",
      "}",
      "",
      "template <typename T>",
      "string to_string(const Modular<T> &number) {",
      "  return to_string(number());",
      "}",
      "",
      "template <typename U, typename T>",
      "U &operator<<(U &stream, const Modular<T> &number) {",
      "  return stream << number();",
      "}",
      "",
      "template <typename U, typename T>",
      "U &operator>>(U &stream, Modular<T> &number) {",
      "  typename common_type<typename Modular<T>::Type, int64_t>::type x;",
      "  stream >> x;",
      "  number.value = Modular<T>::normalize(x);",
      "  return stream;",
      "}",
      "",
      "// using ModType = int;",
      "",
      "// struct VarMod { static ModType value; };",
      "// ModType VarMod::value;",
      "// ModType& md = VarMod::value;",
      "// using Mint = Modular<VarMod>;",
      "",
      "constexpr int md = ${0};",
      "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
      "",
      "// vector<Mint> fact(1, 1);",
      "// vector<Mint> inv_fact(1, 1);",
      "",
      "// Mint C(int n, int k) {",
      "//   if (k < 0 || k > n) {",
      "//     return 0;",
      "//   }",
      "//   while ((int) fact.size() < n + 1) {",
      "//     fact.push_back(fact.back() * (int) fact.size());",
      "//     inv_fact.push_back(1 / fact.back());",
      "//   }",
      "//   return fact[n] * inv_fact[k] * inv_fact[n - k];",
      "// }",
      ""
    ],
    "description": "modulo"
  },
  "segtree": {
    "prefix": "layout",
    "body": [
      "template <typename Info>",
      "class SimpleSegmentTree",
      "{",
      "public:",
      "  int n;",
      "  vector<Info> infos;",
      "  seg_tree::in_order_layout layout;",
      "",
      "  void UpdateNode(seg_tree::point a) {",
      "    infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
      "  }",
      "",
      "  SimpleSegmentTree(int n_) : SimpleSegmentTree(vector<Info>(n_)) {}",
      "",
      "  SimpleSegmentTree(const vector<Info> &a) : n(int(a.size())) {",
      "    assert(n > 0);",
      "    infos.resize(2 * n);",
      "    layout = seg_tree::in_order_layout(n);",
      "    for (int i = 0; i < n; i++) {",
      "      infos[layout.get_point(i)] = a[i];",
      "    }",
      "    for (int i = n - 1; i >= 1; i--) {",
      "      infos[i] = infos[2 * i].Unite(infos[2 * i + 1]);",
      "    }",
      "  }",
      "",
      "  void Set(int p, const Info &v) {",
      "    auto pt = layout.get_point(p);",
      "    infos[pt] = v;",
      "    pt.for_parents_up([&](seg_tree::point a){",
      "      UpdateNode(a); ",
      "    });",
      "  }",
      "",
      "  Info Query(int l, int r) {",
      "    auto rng = layout.get_range(l, r);",
      "    Info res;",
      "    rng.for_each_l_to_r([&](seg_tree::point a){ ",
      "      res = res.Unite(infos[a]); ",
      "    });",
      "    return res;",
      "  }",
      "",
      "  Info Get(int p) {",
      "    auto pt = layout.get_point(p);",
      "    return infos[pt];",
      "  }",
      "",
      "  template <typename F>",
      "  int MaxRight(int l, F f) {",
      "    auto rng = layout.get_range(l, n);",
      "    int res = n;",
      "    Info sum;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) {",
      "      if (res != n) {",
      "        return;",
      "      }",
      "      auto new_sum = sum.Unite(infos[a]);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = sum.Unite(infos[a.c(0)]);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(1);",
      "        } else {",
      "          a = a.c(0);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[0]; });",
      "    return res;",
      "  }",
      "",
      "  template <typename F>",
      "  int MinLeft(int r, F f) {",
      "    auto rng = layout.get_range(0, r);",
      "    int res = 0;",
      "    Info sum;",
      "    rng.for_each_r_to_l([&](seg_tree::point a) {",
      "      if (res != 0) {",
      "          return;",
      "      }",
      "      auto new_sum = infos[a].Unite(sum);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = infos[a.c(1)].Unite(sum);",
      "        if (f(new_sum)) {",
      "        sum = new_sum;",
      "        a = a.c(0);",
      "        } else {",
      "        a = a.c(1);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[1]; });",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "segtree"
  },
  "simple": {
    "prefix": "simple",
    "body": [
      "template <typename Info>",
      "class SimpleSegmentTree {",
      " public:",
      "  int n;",
      "  vector<Info> infos;",
      "  seg_tree::in_order_layout layout;",
      "",
      "  void UpdateNode(seg_tree::point a) {",
      "    infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
      "  }",
      "",
      "  SimpleSegmentTree(int n_) : SimpleSegmentTree(vector<Info>(n_)) {}",
      "",
      "  SimpleSegmentTree(const vector<Info> &a) : n(int(a.size())) {",
      "    assert(n > 0);",
      "    infos.resize(2 * n);",
      "    layout = seg_tree::in_order_layout(n);",
      "    for (int i = 0; i < n; i++) {",
      "      infos[layout.get_point(i)] = a[i];",
      "    }",
      "    for (int i = n - 1; i >= 1; i--) {",
      "      infos[i] = infos[2 * i].Unite(infos[2 * i + 1]);",
      "    }",
      "  }",
      "",
      "  void Set(int p, const Info &v) {",
      "    auto pt = layout.get_point(p);",
      "    infos[pt] = v;",
      "    pt.for_parents_up([&](seg_tree::point a) { UpdateNode(a); });",
      "  }",
      "",
      "  Info Query(int l, int r) {",
      "    auto rng = layout.get_range(l, r);",
      "    Info res;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) { res = res.Unite(infos[a]); });",
      "    return res;",
      "  }",
      "",
      "  Info Get(int p) {",
      "    auto pt = layout.get_point(p);",
      "    return infos[pt];",
      "  }",
      "",
      "  template <typename F>",
      "  int MaxRight(int l, F f) {",
      "    auto rng = layout.get_range(l, n);",
      "    int res = n;",
      "    Info sum;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) {",
      "      if (res != n) {",
      "        return;",
      "      }",
      "      auto new_sum = sum.Unite(infos[a]);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = sum.Unite(infos[a.c(0)]);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(1);",
      "        } else {",
      "          a = a.c(0);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[0];",
      "    });",
      "    return res;",
      "  }",
      "",
      "  template <typename F>",
      "  int MinLeft(int r, F f) {",
      "    auto rng = layout.get_range(0, r);",
      "    int res = 0;",
      "    Info sum;",
      "    rng.for_each_r_to_l([&](seg_tree::point a) {",
      "      if (res != 0) {",
      "        return;",
      "      }",
      "      auto new_sum = infos[a].Unite(sum);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = infos[a.c(1)].Unite(sum);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(0);",
      "        } else {",
      "          a = a.c(1);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[1];",
      "    });",
      "    return res;",
      "  }",
      "};",
      "",
      "struct Info {",
      "  // definition of node",
      "  ${1}",
      "",
      "  Info Unite(const Info &b) const {",
      "    Info res;",
      "    // merge here",
      "    ${0}",
      "    return res;",
      "  }",
      "",
      "  static Info GetDefault([[maybe_unused]] int l, [[maybe_unused]] int r) {",
      "    return Info();",
      "  }",
      "};"
    ],
    "description": "segtree-2"
  }
}
