{
  "contest_multi": {
    "prefix": "contest_multi",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "// clang-format off",
      "#define deb(...) { stringstream _ss(#__VA_ARGS__); string _n; auto _t = {__VA_ARGS__}; auto _i = _t.begin(); while (_i != _t.end() && getline(_ss, _n, ',')) cout << (_n[0] == ' ' ? _n.substr(1) : _n) << \"=\" << *_i++ << \" | \"; cout << endl;   }",
      "#define debarr(x) for(auto i: x) cout << i << ' '; cout << endl;",
      "",
      "using ll = long long int;",
      "const int mod = 1000000007;",
      "// clang-format on",
      "",
      "void solve() {",
      "    ${0}",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "",
      "    int t = 1;",
      "    cin >> t;",
      "    while(t--) {",
      "        solve();",
      "    }",
      "",
      "    return 0;",
      "}",
      ""
    ],
    "description": "contest_multi"
  },
  "contest_single": {
    "prefix": "contest_single",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "// clang-format off",
      "#define deb(...) { stringstream _ss(#__VA_ARGS__); string _n; auto _t = {__VA_ARGS__}; auto _i = _t.begin(); while (_i != _t.end() && getline(_ss, _n, ',')) cout << (_n[0] == ' ' ? _n.substr(1) : _n) << \"=\" << *_i++ << \" | \"; cout << endl;   }",
      "#define debarr(x) for(auto i: x) cout << i << ' '; cout << endl;",
      "",
      "using ll = long long int;",
      "const int mod = 1000000007;",
      "// clang-format on",
      "",
      "void solve() {",
      "    ${0}",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "",
      "    int t = 1;",
      "    while(t--) {",
      "        solve();",
      "    }",
      "",
      "    return 0;",
      "}",
      ""
    ],
    "description": "contest single test case"
  },
  "modulo": {
    "prefix": "mint",
    "body": [
      "template<int MOD, int RT>",
      "struct mint {",
      "    static const int mod = MOD;",
      "    static constexpr mint rt() { return RT; }",
      "    int v;",
      "    explicit operator int() const { return v; }",
      "    mint() : v(0) {}",
      "    mint(i64 _v) {",
      "        v = int((_v % MOD + MOD) % MOD);",
      "    }",
      "    bool operator==(const mint& o) const { return v == o.v; }",
      "    bool operator!=(const mint& o) const { return v != o.v; }",
      "    bool operator<(const mint& o) const { return v < o.v; }",
      "",
      "    // Arithmetic",
      "    mint& operator+=(const mint& o) {",
      "        if ((v += o.v) >= MOD) v -= MOD; return *this;",
      "    }",
      "    mint& operator-=(const mint& o) {",
      "        if ((v -= o.v) < 0) v += MOD; return *this;",
      "    }",
      "    mint& operator*=(const mint& o) {",
      "        v = int((i64)v * o.v % MOD); return *this;",
      "    }",
      "    mint& operator/=(const mint& o) { return *this *= inv(o); }",
      "    mint operator-() const { return mint(-v); }",
      "    mint& operator++() { return *this += 1; }",
      "    mint& operator--() { return *this -= 1; }",
      "    friend mint operator+(mint a, const mint& b) { return a += b; }",
      "    friend mint operator-(mint a, const mint& b) { return a -= b; }",
      "    friend mint operator*(mint a, const mint& b) { return a *= b; }",
      "    friend mint operator/(mint a, const mint& b) { return a /= b; }",
      "    friend std::istream& operator>>(std::istream& in, mint& m) {",
      "        i64 x; in >> x; m = mint(x); return in;",
      "    }",
      "    friend std::ostream& operator<<(std::ostream& out, const mint& m) {",
      "        return out << m.v;",
      "    }",
      "",
      "    // Power and inverse",
      "    friend mint pow(mint a, i64 p) {",
      "        mint res = 1;",
      "        while (p > 0) {",
      "            if (p & 1) res *= a;",
      "            a *= a;",
      "            p >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "",
      "    friend mint inv(const mint& a) {",
      "        assert(a.v != 0);",
      "        return pow(a, MOD - 2);",
      "    }",
      "",
      "    inline static std::vector<mint> fact, ifact;",
      "    static void genFact(int SZ) {",
      "        fact.resize(SZ);",
      "        ifact.resize(SZ);",
      "        fact[0] = 1;",
      "        for (int i = 1; i < SZ; ++i) {",
      "            fact[i] = fact[i - 1] * i;",
      "        }",
      "        ifact[SZ - 1] = inv(fact[SZ - 1]);",
      "        for (int i = SZ - 2; i >= 0; --i) {",
      "            ifact[i] = ifact[i + 1] * (i + 1);",
      "        }",
      "    }",
      "    static mint C(int n, int k) {",
      "        if (k < 0 || k > n) return 0;",
      "        return fact[n] * ifact[k] * ifact[n - k];",
      "    }",
      "};",
      "using mi = mint<mod, 5>;"
    ],
    "description": "modulo"
  },
  "segtree": {
    "prefix": "layout",
    "body": [
      "template <typename Info>",
      "class SimpleSegmentTree",
      "{",
      "public:",
      "  int n;",
      "  vector<Info> infos;",
      "  seg_tree::in_order_layout layout;",
      "",
      "  void UpdateNode(seg_tree::point a) {",
      "    infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
      "  }",
      "",
      "  SimpleSegmentTree(int n_) : SimpleSegmentTree(vector<Info>(n_)) {}",
      "",
      "  SimpleSegmentTree(const vector<Info> &a) : n(int(a.size())) {",
      "    assert(n > 0);",
      "    infos.resize(2 * n);",
      "    layout = seg_tree::in_order_layout(n);",
      "    for (int i = 0; i < n; i++) {",
      "      infos[layout.get_point(i)] = a[i];",
      "    }",
      "    for (int i = n - 1; i >= 1; i--) {",
      "      infos[i] = infos[2 * i].Unite(infos[2 * i + 1]);",
      "    }",
      "  }",
      "",
      "  void Set(int p, const Info &v) {",
      "    auto pt = layout.get_point(p);",
      "    infos[pt] = v;",
      "    pt.for_parents_up([&](seg_tree::point a){",
      "      UpdateNode(a); ",
      "    });",
      "  }",
      "",
      "  Info Query(int l, int r) {",
      "    auto rng = layout.get_range(l, r);",
      "    Info res;",
      "    rng.for_each_l_to_r([&](seg_tree::point a){ ",
      "      res = res.Unite(infos[a]); ",
      "    });",
      "    return res;",
      "  }",
      "",
      "  Info Get(int p) {",
      "    auto pt = layout.get_point(p);",
      "    return infos[pt];",
      "  }",
      "",
      "  template <typename F>",
      "  int MaxRight(int l, F f) {",
      "    auto rng = layout.get_range(l, n);",
      "    int res = n;",
      "    Info sum;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) {",
      "      if (res != n) {",
      "        return;",
      "      }",
      "      auto new_sum = sum.Unite(infos[a]);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = sum.Unite(infos[a.c(0)]);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(1);",
      "        } else {",
      "          a = a.c(0);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[0]; });",
      "    return res;",
      "  }",
      "",
      "  template <typename F>",
      "  int MinLeft(int r, F f) {",
      "    auto rng = layout.get_range(0, r);",
      "    int res = 0;",
      "    Info sum;",
      "    rng.for_each_r_to_l([&](seg_tree::point a) {",
      "      if (res != 0) {",
      "          return;",
      "      }",
      "      auto new_sum = infos[a].Unite(sum);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = infos[a.c(1)].Unite(sum);",
      "        if (f(new_sum)) {",
      "        sum = new_sum;",
      "        a = a.c(0);",
      "        } else {",
      "        a = a.c(1);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[1]; });",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "segtree"
  },
  "simple": {
    "prefix": "simple",
    "body": [
      "template <typename Info>",
      "class SimpleSegmentTree {",
      " public:",
      "  int n;",
      "  vector<Info> infos;",
      "  seg_tree::in_order_layout layout;",
      "",
      "  void UpdateNode(seg_tree::point a) {",
      "    infos[a] = infos[a.c(0)].Unite(infos[a.c(1)]);",
      "  }",
      "",
      "  SimpleSegmentTree(int n_) : SimpleSegmentTree(vector<Info>(n_)) {}",
      "",
      "  SimpleSegmentTree(const vector<Info> &a) : n(int(a.size())) {",
      "    assert(n > 0);",
      "    infos.resize(2 * n);",
      "    layout = seg_tree::in_order_layout(n);",
      "    for (int i = 0; i < n; i++) {",
      "      infos[layout.get_point(i)] = a[i];",
      "    }",
      "    for (int i = n - 1; i >= 1; i--) {",
      "      infos[i] = infos[2 * i].Unite(infos[2 * i + 1]);",
      "    }",
      "  }",
      "",
      "  void Set(int p, const Info &v) {",
      "    auto pt = layout.get_point(p);",
      "    infos[pt] = v;",
      "    pt.for_parents_up([&](seg_tree::point a) { UpdateNode(a); });",
      "  }",
      "",
      "  Info Query(int l, int r) {",
      "    auto rng = layout.get_range(l, r);",
      "    Info res;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) { res = res.Unite(infos[a]); });",
      "    return res;",
      "  }",
      "",
      "  Info Get(int p) {",
      "    auto pt = layout.get_point(p);",
      "    return infos[pt];",
      "  }",
      "",
      "  template <typename F>",
      "  int MaxRight(int l, F f) {",
      "    auto rng = layout.get_range(l, n);",
      "    int res = n;",
      "    Info sum;",
      "    rng.for_each_l_to_r([&](seg_tree::point a) {",
      "      if (res != n) {",
      "        return;",
      "      }",
      "      auto new_sum = sum.Unite(infos[a]);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = sum.Unite(infos[a.c(0)]);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(1);",
      "        } else {",
      "          a = a.c(0);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[0];",
      "    });",
      "    return res;",
      "  }",
      "",
      "  template <typename F>",
      "  int MinLeft(int r, F f) {",
      "    auto rng = layout.get_range(0, r);",
      "    int res = 0;",
      "    Info sum;",
      "    rng.for_each_r_to_l([&](seg_tree::point a) {",
      "      if (res != 0) {",
      "        return;",
      "      }",
      "      auto new_sum = infos[a].Unite(sum);",
      "      if (f(new_sum)) {",
      "        sum = new_sum;",
      "        return;",
      "      }",
      "      while (a < n) {",
      "        new_sum = infos[a.c(1)].Unite(sum);",
      "        if (f(new_sum)) {",
      "          sum = new_sum;",
      "          a = a.c(0);",
      "        } else {",
      "          a = a.c(1);",
      "        }",
      "      }",
      "      res = layout.get_node_bounds(a)[1];",
      "    });",
      "    return res;",
      "  }",
      "};",
      "",
      "struct Info {",
      "  // definition of node",
      "  ${1}",
      "",
      "  Info Unite(const Info &b) const {",
      "    Info res;",
      "    // merge here",
      "    ${0}",
      "    return res;",
      "  }",
      "",
      "  static Info GetDefault([[maybe_unused]] int l, [[maybe_unused]] int r) {",
      "    return Info();",
      "  }",
      "};"
    ],
    "description": "segtree-2"
  },
  "Disjoint Set Union": {
    "prefix": "dsu",
    "body": [
      "struct DSU {",
      "vector<int> e; DSU(int N) { e = vector<int>(N,-1); }",
      "int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }",
      "bool sameSet(int a, int b) { return get(a) == get(b); }",
      "int size(int x) { return -e[get(x)]; }",
      "bool unite(int x, int y) { // union by size",
      "x = get(x), y = get(y); if (x == y) return 0;",
      "if (e[x] > e[y]) swap(x,y);",
      "e[x] += e[y]; e[y] = x; return 1;",
      "}",
      "};"
    ],
    "description": "Disjoint Set Union"
  },

  "bit": {
    "prefix": "bit",
    "body": [
      "template <class T> class BIT {",
      "  private:",
      "	int size;",
      "	vector<T> bit;",
      "	vector<T> arr;",
      "",
      "  public:",
      "	BIT(int size) : size(size), bit(size + 1), arr(size) {}",
      "",
      "	void set(int ind, int val) { add(ind, val - arr[ind]); }",
      "",
      "	void add(int ind, int val) {",
      "		arr[ind] += val;",
      "		ind++;",
      "		for (; ind <= size; ind += ind & -ind) { bit[ind] += val; }",
      "	}",
      "",
      "	T pref_sum(int ind) {",
      "		ind++;",
      "		T total = 0;",
      "		for (; ind > 0; ind -= ind & -ind) { total += bit[ind]; }",
      "		return total;",
      "	}",
      "};"
    ],
    "description": "Binary Index Tree"
  },
  "usaco": {
    "prefix": "usaco",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "#define rep(i,k,n)  for(ll i=k;k<n?i<n:i>n;k<n?i+=1:i-=1)",
      "#define debarr(arr) for(ll xxx = 0; xxx < arr.size(); xxx++) cout <<  arr[xxx] << ' '; cout<< endl;",
      "#define deb(x)   cout << #x << \"=\" << x << endl",
      "#define deb2(z, x, y)  cout << #z \": (\" << x << \", \" << y << \")\\n\";",
      "#define ll long long",
      "#define pb push_back",
      "#define mp make_pair",
      "#define F first",
      "#define S second",
      "#define all(x)  x.begin(), x.end()",
      "#define clr(x)  memset(x, 0, sizeof(x))",
      "#define sz(x) (int) (x).size()",
      "#define sortall(x) sort(all(x))",
      "#define tr(it, a) for(auto it = a.begin(); it != a.end(); it++)",
      "#define PI 3.1415926535897932384626",
      "typedef pair<int, int> pii;",
      "typedef pair<ll, ll> pl;",
      "typedef vector<int>  vi;",
      "typedef vector<ll>  vl;",
      "typedef vector<pii>  vpii;",
      "typedef vector<pl>  vpl;",
      "typedef vector<vi>  vvi;",
      "typedef vector<vl>  vvl;",
      "mt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());",
      "int rng(int lim) {",
      "    uniform_int_distribution<int> uid(0,lim-1);",
      "    return uid(rang);",
      "}",
      "void setIO(string name = \"\") {",
      "    if (sz(name)) {",
      "        freopen((name + \".in\").c_str(), \"r\", stdin); // see /general/input-output",
      "        freopen((name + \".out\").c_str(), \"w\", stdout);",
      "    }",
      "}",
      "const int mod = 1000000007;",
      "const int N = 1e6 + 7, M = N;",
      "//=======================",
      "",
      "",
      "void solve() {",
      "    ",
      "}",
      "",
      "",
      "int main() {",
      "    srand(chrono::high_resolution_clock::now().time_since_epoch().count());",
      "    auto begin = std::chrono::high_resolution_clock::now();",
      "",
      "    // setIO(\"\");",
      "    #ifndef ONLINE_JUDGE",
      "        freopen(\"input.txt\",\"r\",stdin);",
      "        freopen(\"output.txt\",\"w\",stdout);",
      "        freopen(\"error.txt\",\"w\",stderr);",
      "    #endif",
      "",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "",
      "    int t = 1;",
      "    cin >> t;",
      "    while(t--) {",
      "        solve();",
      "    }",
      "",
      "    auto end = std::chrono::high_resolution_clock::now();",
      "    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);",
      "    cerr << \"=>\" << elapsed.count() * 1e-6 << \" ms.\";",
      "    return 0;",
      "}",
      ""
    ],
    "description": "infinity"
  }
}
